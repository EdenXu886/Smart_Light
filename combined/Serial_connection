#include <string.h>
#include "esp_now.h"
#include "esp_wifi.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "driver/gpio.h"
#include "esp_mac.h"

#define BUTTON_GPIO GPIO_NUM_0
#define LED_GPIO    GPIO_NUM_2      // Main chip LED
#define LEFT_LED_GPIO GPIO_NUM_4   // LED for left neighbor connection
#define RIGHT_LED_GPIO GPIO_NUM_5  // LED for right neighbor connection

#define DEBOUNCE_TIME_MS 50
#define TAG "ESP_NOW_APP"

// Structure for the message to send
typedef struct {
    uint8_t sender_mac[6];
    bool button_pressed;
} espnow_message_t;

// Replace these with actual MACs for each device
uint8_t NEIGHBOR_1_MAC[] = {0x24, 0x6F, 0x28, 0xAB, 0xCD, 0x01};  // Left neighbor MAC
uint8_t NEIGHBOR_2_MAC[] = {0x24, 0x6F, 0x28, 0xAB, 0xCD, 0x02};  // Right neighbor MAC

volatile bool button_state = false;
bool neighbor1_connected = false;  // Left neighbor connection status
bool neighbor2_connected = false;  // Right neighbor connection status
bool neighbor1_pressed = false;    // Left neighbor button state
bool neighbor2_pressed = false;    // Right neighbor button state

// Send button press state to both neighbors
void send_button_state() {
    espnow_message_t msg;
    esp_wifi_get_mac(WIFI_IF_STA, msg.sender_mac);
    msg.button_pressed = button_state;

    // Send to left and right neighbors
    esp_now_send(NEIGHBOR_1_MAC, (uint8_t *)&msg, sizeof(msg));
    esp_now_send(NEIGHBOR_2_MAC, (uint8_t *)&msg, sizeof(msg));
}

// Update the main LED based on the button state and neighbors' button state
void update_led_state() {
    // Main LED lights up when own button is pressed and either neighbor button is pressed
    if (button_state && (neighbor1_pressed || neighbor2_pressed)) {
        gpio_set_level(LED_GPIO, 1);
    } else {
        gpio_set_level(LED_GPIO, 0);
    }

    // Left neighbor LED lights up when left neighbor is connected and actively sending messages
    gpio_set_level(LEFT_LED_GPIO, neighbor1_connected ? 1 : 0);

    // Right neighbor LED lights up when right neighbor is connected and actively sending messages
    gpio_set_level(RIGHT_LED_GPIO, neighbor2_connected ? 1 : 0);
}

// Callback function to handle received messages
void on_data_recv(const uint8_t *mac_addr, const uint8_t *data, int data_len) {
    if (data_len != sizeof(espnow_message_t)) return;

    espnow_message_t *msg = (espnow_message_t *)data;

    if (memcmp(mac_addr, NEIGHBOR_1_MAC, 6) == 0) {
        neighbor1_pressed = msg->button_pressed;
        neighbor1_connected = true;  // Mark left neighbor as connected
    } else if (memcmp(mac_addr, NEIGHBOR_2_MAC, 6) == 0) {
        neighbor2_pressed = msg->button_pressed;
        neighbor2_connected = true;  // Mark right neighbor as connected
    }

    update_led_state();
}

// Initialize ESP-NOW and wifi configurations
void app_main() {
    // Initialize NVS (Non-Volatile Storage)
    nvs_flash_init();
    esp_netif_init();
    esp_event_loop_create_default();

    wifi_init_config_t cfg = WIFI_INIT_CONFIG_DEFAULT();
    esp_wifi_init(&cfg);
    esp_wifi_set_mode(WIFI_MODE_STA);
    esp_wifi_start();

    // Initialize ESP-NOW and register the receive callback
    esp_now_init();
    esp_now_register_recv_cb(on_data_recv);

    // Add neighbors as peers (Left and Right neighbors)
    esp_now_peer_info_t peerInfo = {
        .channel = 0,
        .encrypt = false
    };

    // Add Left neighbor
    memcpy(peerInfo.peer_addr, NEIGHBOR_1_MAC, 6);
    esp_now_add_peer(&peerInfo);

    // Add Right neighbor
    memcpy(peerInfo.peer_addr, NEIGHBOR_2_MAC, 6);
    esp_now_add_peer(&peerInfo);

    // Setup GPIOs
    gpio_reset_pin(BUTTON_GPIO);
    gpio_set_direction(BUTTON_GPIO, GPIO_MODE_INPUT);
    gpio_set_pull_mode(BUTTON_GPIO, GPIO_PULLUP_ONLY);

    gpio_reset_pin(LED_GPIO);
    gpio_set_direction(LED_GPIO, GPIO_MODE_OUTPUT);

    gpio_reset_pin(LEFT_LED_GPIO);
    gpio_set_direction(LEFT_LED_GPIO, GPIO_MODE_OUTPUT);

    gpio_reset_pin(RIGHT_LED_GPIO);
    gpio_set_direction(RIGHT_LED_GPIO, GPIO_MODE_OUTPUT);

    bool last_state = gpio_get_level(BUTTON_GPIO);

    while (1) {
        bool current_state = gpio_get_level(BUTTON_GPIO) == 0; // Active-low button
        if (current_state != last_state) {
            vTaskDelay(pdMS_TO_TICKS(DEBOUNCE_TIME_MS));
            if (current_state == (gpio_get_level(BUTTON_GPIO) == 0)) {
                last_state = current_state;
                button_state = current_state;
                send_button_state();
                update_led_state();
            }
        }
        vTaskDelay(pdMS_TO_TICKS(10)); // Polling delay
    }
}
